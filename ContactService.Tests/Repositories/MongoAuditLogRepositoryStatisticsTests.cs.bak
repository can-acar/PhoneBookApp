using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using ContactService.Domain.Entities;
using ContactService.Infrastructure.Data;
using ContactService.Infrastructure.Repositories;
using FluentAssertions;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using MongoDB.Bson;
using MongoDB.Driver;
using Moq;
using Xunit;

namespace ContactService.Tests.Repositories
{
    public class MongoAuditLogRepositoryStatisticsTests
    {
        private readonly Mock<MongoDbContext> _mockMongoContext;
        private readonly Mock<ILogger<MongoAuditLogRepository>> _mockLogger;
        private readonly Mock<IMongoCollection<AuditLog>> _mockCollection;
        private readonly MongoAuditLogRepository _repository;

        public MongoAuditLogRepositoryStatisticsTests()
        {
            // Mock IConfiguration to provide connection string
            var mockConfiguration = new Mock<IConfiguration>();
            var mockSection = new Mock<IConfigurationSection>();
            mockSection.Setup(x => x.Value).Returns("mongodb://localhost:27017/ContactServiceTest");
            mockConfiguration
                .Setup(x => x.GetSection("ConnectionStrings:MongoDB"))
                .Returns(mockSection.Object);

            // Moq doesn't support extension method mocking, so we can't mock GetConnectionString directly
            var mockConnectionStringsSection = new Mock<IConfigurationSection>();
            mockConfiguration
                .Setup(x => x.GetSection("ConnectionStrings"))
                .Returns(mockConnectionStringsSection.Object);

            var mockMongoDbSection = new Mock<IConfigurationSection>();
            mockMongoDbSection.Setup(x => x.Value).Returns("mongodb://localhost:27017/ContactServiceTest");
            mockConnectionStringsSection
                .Setup(x => x.GetSection("MongoDB"))
                .Returns(mockMongoDbSection.Object);
                
            _mockMongoContext = new Mock<MongoDbContext>(
                mockConfiguration.Object,
                Mock.Of<ILogger<MongoDbContext>>());
            
            _mockLogger = new Mock<ILogger<MongoAuditLogRepository>>();
            _mockCollection = new Mock<IMongoCollection<AuditLog>>();
            
            // Setup MongoDB collection
            _mockMongoContext
                .Setup(x => x.AuditLogs)
                .Returns(_mockCollection.Object);
            
            _repository = new MongoAuditLogRepository(_mockMongoContext.Object, _mockLogger.Object);
        }

        [Fact(Skip = "Temporarily disabled due to MongoDB mocking complexity")]
        public async Task GetStatisticsAsync_ShouldReturnServiceStatistics()
        {
            // Arrange
            var startTime = DateTime.UtcNow.AddDays(-7);
            var endTime = DateTime.UtcNow;

            var expectedResults = new List<BsonDocument>
            {
                new BsonDocument
                {
                    { "_id", "ContactService" },
                    { "count", 42 },
                    { "actions", new BsonArray(new[] { "CREATE", "UPDATE", "DELETE" }) },
                    { "entityTypes", new BsonArray(new[] { "Contact", "ContactInfo" }) }
                },
                new BsonDocument
                {
                    { "_id", "ReportService" },
                    { "count", 18 },
                    { "actions", new BsonArray(new[] { "GENERATE", "DOWNLOAD" }) },
                    { "entityTypes", new BsonArray(new[] { "Report" }) }
                }
            };

            SetupAggregateCursor(expectedResults);

            // Act
            var result = await _repository.GetStatisticsAsync(startTime, endTime);

            // Assert
            result.Should().NotBeNull();
            result.Should().HaveCount(2);
            result["ContactService"].Should().Be(42);
            result["ReportService"].Should().Be(18);
        }

        [Fact(Skip = "Temporarily disabled due to MongoDB mocking complexity")]
        public async Task GetStatisticsAsync_WithNoTimeFilter_ShouldReturnAllStatistics()
        {
            // Arrange
            var expectedResults = new List<BsonDocument>
            {
                new BsonDocument
                {
                    { "_id", "ContactService" },
                    { "count", 100 },
                    { "actions", new BsonArray(new[] { "CREATE", "UPDATE", "DELETE" }) },
                    { "entityTypes", new BsonArray(new[] { "Contact", "ContactInfo" }) }
                }
            };

            SetupAggregateCursor(expectedResults);

            // Act
            var result = await _repository.GetStatisticsAsync();

            // Assert
            result.Should().NotBeNull();
            result.Should().HaveCount(1);
            result["ContactService"].Should().Be(100);
        }

        [Fact(Skip = "Temporarily disabled due to MongoDB mocking complexity")]
        public async Task GetActionStatisticsAsync_ShouldReturnActionCounts()
        {
            // Arrange
            var startTime = DateTime.UtcNow.AddDays(-7);
            var endTime = DateTime.UtcNow;

            var expectedResults = new List<BsonDocument>
            {
                new BsonDocument
                {
                    { "_id", "CREATE" },
                    { "count", 25 }
                },
                new BsonDocument
                {
                    { "_id", "UPDATE" },
                    { "count", 15 }
                },
                new BsonDocument
                {
                    { "_id", "DELETE" },
                    { "count", 10 }
                }
            };

            SetupAggregateCursor(expectedResults);

            // Act
            var result = await _repository.GetActionStatisticsAsync(startTime, endTime);

            // Assert
            result.Should().NotBeNull();
            result.Should().HaveCount(3);
            result["CREATE"].Should().Be(25);
            result["UPDATE"].Should().Be(15);
            result["DELETE"].Should().Be(10);
        }

        [Fact(Skip = "Temporarily disabled due to MongoDB mocking complexity")]
        public async Task GetServiceStatisticsAsync_ShouldCallGetStatisticsAsync()
        {
            // Arrange
            var startTime = DateTime.UtcNow.AddDays(-7);
            var endTime = DateTime.UtcNow;

            var expectedResults = new List<BsonDocument>
            {
                new BsonDocument
                {
                    { "_id", "ContactService" },
                    { "count", 42 }
                }
            };

            SetupAggregateCursor(expectedResults);

            // Act
            var result = await _repository.GetServiceStatisticsAsync(startTime, endTime);

            // Assert
            result.Should().NotBeNull();
            result.Should().HaveCount(1);
            result["ContactService"].Should().Be(42);
        }
        
        [Fact(Skip = "Temporarily disabled due to MongoDB mocking complexity")]
        public async Task GetStatisticsAsync_EmptyResult_ShouldReturnEmptyDictionary()
        {
            // Arrange
            SetupAggregateCursor(new List<BsonDocument>());

            // Act
            var result = await _repository.GetStatisticsAsync();

            // Assert
            result.Should().NotBeNull();
            result.Should().BeEmpty();
        }
        
        [Fact(Skip = "Temporarily disabled due to MongoDB mocking complexity")]
        public async Task GetActionStatisticsAsync_EmptyResult_ShouldReturnEmptyDictionary()
        {
            // Arrange
            SetupAggregateCursor(new List<BsonDocument>());

            // Act
            var result = await _repository.GetActionStatisticsAsync();

            // Assert
            result.Should().NotBeNull();
            result.Should().BeEmpty();
        }

        #region Helper Methods

        private void SetupAggregateCursor(List<BsonDocument> documents)
        {
            // Create a fluent mock that properly handles ToListAsync
            var mockAggregateFluent = new Mock<IAggregateFluent<BsonDocument>>();
            mockAggregateFluent
                .Setup(x => x.ToListAsync(It.IsAny<CancellationToken>()))
                .ReturnsAsync(documents);
                
            _mockCollection
                .Setup(x => x.Aggregate(It.IsAny<PipelineDefinition<AuditLog, BsonDocument>>()))
                .Returns(mockAggregateFluent.Object);
        }

        #endregion
    }
}
